# Lua5.0的实现
> 译自Lua官方的论文[《The Implementation of Lua 5.0》](https://www.lua.org/doc/jucs05.pdf)

## 1、导语
Lua本是一个诞生于学术实验室中的内部软件开发工具，却意外地被全球多个业界项目采用，现在已经被广泛用于游戏行业中。

该如何解释Lua被广泛应用的现象呢？我们觉得答案在于我们设计和实现的目的：提供一个简单、高效、可移植且轻量的嵌入式脚本语言。从Lua诞生开始，这些一直是我们的主要目标，且在其发展过程中，也一直被尊重着。这些特性以及Lua从设计之初就是为了嵌入大型应用程序中的这一事实，解释了其较早被业界采用的现象。（Lua类似于MIT的许可政策也是被业界采用的原因之一。）

由于被广泛使用，从而产生了对语言特性的需求。Lua的很多特性都是因业界需要和用户反馈而提出的。其中比较重要的有Lua5.0中引入的协程和即将到来的Lua5.1中的增量GC实现。这都是对游戏尤为重要的特性。

在本文中，我们将讨论以下在Lua5.0中的实现相较于Lua4.0的主要变化：

- ***基于寄存器的虚拟机***：通常大部分用于执行动作的虚拟机都是基于栈的，这种趋势从Pascal的P-machine开始，持续到如今Java的JVM和微软的.Net环境。然而现在对于基于寄存器的虚拟机的热情正在增长（例如，计划中的Perl6(Parrot)的新虚拟机就是基于寄存器的）。据我们了解，Lua5.0是第一个广泛使用的基于寄存器的虚拟机。这些将在本文的第七节中讨论。
- ***优化表作为数组使用时的新算法***：不像其他的脚本语言，Lua并未提供数组类型。Lua程序员们使用整数索引的常规表来代替实现数组。Lua5.0使用了一个新算法来检测表是否被用作一个数组并自动将数字索引的值存在一个真实的数组中，而不是将其加到哈希表里。本文将在第4节中讨论该算法。
- ***闭包的实现***：Lua5.0在语法域中将函数作为一等公民。这种机制对于使用基于数组的栈来存储活跃记录的语言带来了一个公认的难点。Lua使用了一种新方法来处理函数闭包，其将局部变量保留在（基于数组的）栈中并且只在它们出了嵌套函数的引用范围时才将其移动到堆中。本文将在第5节中讨论闭包的实现。
- ***协程的加入***：Lua5.0引入了协程到语言中。尽管协程的实现多少有些稀疏平常，但为了完整起见，我们还是将在第6节中做些简要的介绍。

其他章节的内容都是作为这些论点的补充和背景。在第2节中我们将介绍Lua的设计目标以及如何推崇这些目标的实现。第3节中我们会描述Lua如何表示其中的值。尽管这些表示方法本身并无新意，但是我们仍然需要这些材料来为其他章节作铺垫。最后，在第8节中我们提出了一个小的性能基准并得出了一些结论。

## 2、Lua设计与实现一览
如导语中所述，在Lua中我们的实现目标分别是：

- ***简单***：我们所寻求的是可接受的、足够简单的语言，以及用于实现这个语言的C代码也足够简单。这意味着需要一种语言结构少、比较传统的简单语法。
- ***高效***：我们追求Lua程序的快速编译和快速执行。这意味着需要一个快速、智能的单遍编译器（one-pass compiler）和一个高效的虚拟机。
- ***可移植***：我们希望Lua运行在尽可能多的平台上。我们希望在任何地方不用更改也可以编译Lua核心，并且只要对应的平台有合适的解释器，就可以在不做任何更改的情况下运行Lua程序。这意味着要使用简洁的ANSI标准C来实现，还要特别小心可移植性问题，例如C语言和C库的灰色地带，并确保它也可以直接作为C++代码编译。我们追求编译中无警告。
- ***嵌入式***：Lua是一门扩展语言；它是作为大型应用程序的脚本工具而设计的。这一目标和其他目标都意味着需要一套简单强大的C API，并主要依赖C语言内置的类型。
- ***低嵌入成本***：我们希望可以很简单得将Lua添加到大型应用程序中，却不会使其变得臃肿。这意味着需要紧凑的C代码以及Lua的核心不能太大，扩展部分则作为用户库来进行添加。

这些目标在某种程度上有些冲突。例如，Lua常被作为数据描述语言来存储或加载配置文件以及有时用来作为大型数据库（几MB的Lua程序并不少见）。这意味着我们需要一个高速编译器。另一方面，我们还希望Lua的执行也很快。这意味着需要一个足够智能的编译器，以生成良好的虚拟机代码。因此，Lua编译器的实现需要平衡好这两个方面。然而，编译器不能太大；否则会使得整个包变得臃肿。当前版本的编译器约占整个Lua核心大小的30%。对于内存受限的系统，比如嵌入式系统，可以嵌入不含编译器的Lua。Lua程序可以离线提前编译好，然后在运行时通过一个很小的模块加载（这也会更快，因为其加载的是二进制文件）。

Lua用的扫描器和递归下降解析器是我们自己手写的。在3.0版本之前，Lua使用的解析器都是由编译器代码生成器（yacc）生成出来的——它在语法不稳定时是一个值得使用的工具。然而，手写的解析器更小、更高效、可移植性更好并且完全可重入。同时它还可以更好地展示错误信息。

Lua编译器没有使用中间表示。在解析程序时会“即时”地向虚拟机发出指令。尽管如此，编译器还是会执行一些优化操作。例如，其会延迟生成像变量和常量等基本表达式的代码。解析这些表达式时并不会立刻生成代码，而是会使用一个简单的结构体来表示它们。因此，可以很容易地检查所给指令的操作是否未一个常量或局部变量，从而在指令中直接使用它们的值，如此就可以避免不必要且代价高昂的转移动作（参见第三节）。

为了可以在许多不同的C编译器和平台之间移植，Lua无法使用很多解释器常用的技巧，例如直接线程代码（即“direct thread code”，该技术需要对代码段的label取址，虽然主流C编译器都支持该特性，但终究不在ANSI标准中）。相应的，Lua使用标准的 while-switch 模式循环分发指令。另外，一些地方的C代码似乎过于复杂，但是这种复杂的存在是为了保证可移植性。多年来Lua实现的可移植性不断提高，Lua可以在很多不同的编译器和平台下编译（包括各种64位平台和部分16位平台）。

我们认为我们已经完成了我们的设计和实现目标。Lua是一个可移植性很好的语言：从嵌入式系统到大型机，它可以运行在带有ANSI标准C编译器的任意机器上。Lua是很轻量的：例如，在Linux上的独立解释器，其包含所有的标准库在内，一共不到150KB；其核心部分不到100KB。Lua是很高效的：独立的基准测试表明了Lua是脚本语言（即解释型和动态类型的语言）领域中最快的语言实现。我们还是认为Lua是一门简洁的语言，它的语法设计类似于Pascal，语义设计类似于Scheme，当然，这是我们自己的主观想法。

## 3、值的表示法
Lua是一门动态类型语言：类型与值而不是变量相关联。Lua有八种基本类型：***nil***、***boolean***、***number***、***string***、***table***、***function***、***userdata***、以及 ***thread*** 。***nil*** 是一种只有一个值的标记类型，也叫做空值。***boolean*** 类型的值就是常见的 **true** 和 **false**。***number*** 类型为双精度浮点数，在C中对应着 **double** 类型，但是可以很方便地使用 **float** 或 **long** 类型来编译Lua（很多游戏机和小型机缺少对double的支持）。***string*** 是已知大小的字节数组，所以也可以包含任意二进制数据，包括嵌入的零值。 ***table*** 是一种关联数组，其可以由任意值作为索引（除了 ***nil***）且可以持有任意值。***function*** 同时表示Lua函数或按照与Lua虚拟机交互的约定所编写的C函数。***userdata*** 本质上是一个指向用户内存块的指针，并且有两种：*heavy*，它的内存块由Lua分配并由GC管理；以及 *light*，其内存块是由用户分配并释放的。最后，***thread*** 类型表示协程。这些类型都是一等公民（first-class）：我们可以将这些类型的值存储在全局变量、局部变量和表字段中，将其作为函数的参数传入，或作为函数的返回值等。

```C
typedef union {
    GCObject *gc;
    void *p;
    lua_Number n;
    int b;
} Value;

typedef struct {
    int t;
    Value v;
} TObject;
```
<center>
    <p><b>代码段1</b> Lua值是由带标记的联合体实现的</p>
</center>

Lua的值表示为带标记的联合体，即一对值（t, v），其中t是一个唯一标识了值v的类型的整数标记，v是一个C代码中union类型实现的的联合体。***nil***是个单一的值。***boolean*** 和 ***number*** 是作为“开箱即用”的值来实现的：这些类型直接放入到了联合体中。这意味着该联合体必须有足够的空间容纳**double**类型。***string***、***table***、***function***、***thread***、以及 ***userdata*** 类型的值都作为引用来实现：联合体中的v包含了指向这些类型各自的结构体实现。这些结构体共享一个通用的头部，其中带有GC所需要的信息。结构体的剩余部分则根据每种类型有所区分。

代码段1中简单展示了Lua值的具体实现。其中TObject是该实现中的主要结构体：其描述了上文中带标记的联合体（t, v）。Value是实现了值的联合体。***nil***类型的值在该联合体中并没有明确表示出来，因为标记的值就足以标识它了。字段n用作 ***number*** (默认情况下，lua_Number为**double**类型)。字段b用作 ***boolean***。字段p用作*light* ***userdata***。字段gc则作为其他类型的值（***string***、***function***、*heavy* ***userdata***、以及 ***thread***），它们都受GC管理。

使用带标记的联合体来标识Lua值所导致的一个后果是值拷贝的成本有些高昂：在使用64位**double**的32位机器上，TObject的大小为12字节（或者16字节，当**double**以8字节对齐时）因此做值拷贝需要赋值3（或4）个机器字。然而很难在ANSI标准C中实现出更好的值表示方法。有很多动态类型语言（例如Smalltalk80的原实现）使用指针的空闲位来存储值的类型。这种技巧在大部分机器上都适用，由于内存对齐机制，指针最后的2到3位总是0，从而可以用于其他目的。但是，这种技术在ANSI标准C中是不可移植，也是不可实现的。标准C中甚至不保证指针适用于任意基本类型，因此不存在对于指针做位操作的标准方法。

另一种减小值大小的方式是保留显示的标记，但要把double从联合体中删除。比方说，所有的 ***number*** 都可以用一个在堆上分配的对象来表示，就像 ***string*** 一样。（Python就使用了这种技术，不同在于其会提前分配一些小整数值。）然而，这种表示方法会使语言彻底变慢。或是另外一种方式，整数还是作为开箱即用的值直接放入联合体中，而浮点数值放到堆上。然而这种方案会使得所有算术操作的复杂度大大增加。

与一些早期的解释型语言类似，如Snobol和Icon，Lua的内部字符串（*internalizes* string）使用了一个哈希表：其持有着每个重复字符串的唯一拷贝。此外，字符串是不可变的：即只有一次初始化动作，字符串是不可以被改变的。字符串的哈希值是由一个简单混合了位运算和算术运算的表达式计算得到，以此混淆所有涵盖到的位。字符串在初始化时会存储其哈希值，以便快速比较字符串和表索引。当字符串实在太长时，哈希函数并不会查看字符串所有字节。这是为了方便快速哈希长字符串，避免处理长字符串时的性能损失是至关重要的，因为在Lua中常常遇到长字符。比如，在Lua中处理文件时，常常将其整个读到内存中作为一个单独的长字符串。

## 4、表
表是Lua中主要的（事实上是唯一的）数据结构机制。在语言中对表的良好实现所作出的努力都是值得的，因为在内部很多任务都用到了表，却没有出现令人担忧的性能问题。这有助于保持语言实现的规模。但反过来说，因其他数据结构机制的缺失，使得压力都来到了表实现的效率上。

Lua中的表是关联数组（*associative arrays*），即，可以通过任意值索引（除了 ***nil***）且可以持有任意类型的值。此外，它还是动态的，因为当数据被添加（给一个此前不存在的字段赋值）进来的时增长，而当数据被移除（将某个字段赋值为 ***nil***）时会收缩。

和很多其他的脚本语言不同，Lua没有数组类型。数组是用整数索引的表来表示的。表的这种用法给语言带来了不少益处。其中最主要的一点就是简单性：Lua不需要使用两套不同的操作来处理表和数组。另外，编程人员也不需要在两者之间做选择。可以十分轻易地在Lua中实现稀疏数组。例如在Perl中，当你运行 **$a\[100000000\]=1;** 时会导致内存溢出，因为会触发一个包含一亿个元素的数组的分配动作。而在Lua中运行等效的**a={\[100000000\]=1}**，只会创建包含一个字段的表。

<center>
    <img src="/A-Lua-Table.png">
    <p><b>图2</b> Lua表结构</p>
</center>

一直到Lua4.0，表都是作为严格的哈希表实现的：所有的键值对都是显式存储的。Lua5.0带来了一套新算法，用于优化作为数组使用的表：对于整数索引的键值对，不存储其键，而是将其值存到一个真实数组中。更准确地说，在Lua5.0中，表被实现为一个混合的数据结构：其同时包含了哈希和数组的部分。图2展示了一个包含键值对 "x" → 9.3、 1 → 100、2 → 200、 3 → 300 的表。注意右边的数组部分：其没有存储整数键。这种划分只存在于底层实现上；对表属性的访问是透明的，即使对于虚拟机而言。表会根据其内容来自动且动态地调整这两个部分：数组部分会尝试存储1到某个有限地n整数键范围内的值。被非整数键关联的值或是被超出了数组范围的整数键引用的值会被存储在哈希表的部分。

当表需要增长时，Lua会重新计算其哈希表和数组部分的大小。这两个部分都可以为空。数组部分长度为满足这些条件下的一个最大值 *n* ：在1号到 *n* 号位置之间最少有一半的位置是有值的（以避免数组稀疏而浪费空间），并且在第 *n*/2+1 和 *n* 之间的位置中至少有一个值占用（为了避免浪费 *n*/2 ~ *n*之间的空间）。当计算完数组的最新长度后，Lua会创建新的空间并将之前的的元素重新插入。举个例子：假设有一个空表 *a* ，那么其数组部分和哈希表部分的大小都是0。如果我们执行 *a*\[1\] = *v* ，那么此时这个表就需要变大，以容纳新的键。Lua将会选择 *n* = 1 作为数组部分的新长度。哈希部分将继续空着。

这样的混合方案具有两个优势。首先，因为不必做哈希，访问整数索引的值会更快。其次，也是更重要的一点：数组实现对空间的占用几乎是原本哈希表的一半，因为键在数组中是隐式的，而在哈希表中确是显式的。总之，如果是一个作为数组使用的表，且它的整数键分布密集，那么它就会被实现为一个数组。此外，因为没有哈希部分，所以无需付出更多的时间和空间成本。反之亦然，如果是一个作为关联数组使用的表，并且不是个事实上的连续数组，那么其数组部分就是空的。这种对内存的节约特性十分重要，因为在Lua编程中常常会创建多个较小的表，比如使用表来实现对象的时候。

哈希部分使用了一种混合了Brent变体和链式离散表的方法（即使用链表存储，各元素在链表上的分布算法来自于Brent方法：尽可能快速收敛查找范围，而后再使用高精度查找）。如果 有一个元素不在其主位置上（即原本由哈希值得出的位置），那么在该主位置上的就是其碰撞元素。换句话说就是只有主位置相同的元素之间才会发生碰撞（两个元素的哈希值相同）。并且不存在二次碰撞。因此这些表的负载可以达到100%而不影响性能。

## 5、函数和闭包
当Lua编译某个函数时，它会生成一个 *prototype* ——其中包含了该函数在虚拟机中的表示、该函数的常量（数字、常量字符串等），以及一些调试信息。在运行时中，每当Lua执行一个 **function...end** 表达式时，都会创建一个新的 *closure* (闭包)。每个闭包都包含一个对应 *prototype* 的引用、一个对其环境 *environment* （一个用于查找全局变量的表）、以及一个包含了多个引用的数组，每个引用都指向函数的上值——用于访问外部的本地变量。

函数在词法上是有作用域的，同时它又是一等公民的类型，这两点会带来一个众所周知的难点——访问外部的本地变量。思考下边代码段3中的示例：当 **add2** 被调用时，其函数体会访问外部的本地变量 **x** （函数的参数在Lua中是本地变量）。然而，在 **add2** 被调用的时候，创建 **add2** 的 **add** 函数已经返回了。如果 **x** 是创建在调用栈上的，那么它在栈中的位置已不再存在了。

```lua
function add(x)
    return function (y)
                return x+y
           end
end

add2 = add(2)
print(add2(5))
```
<center>
    <p><b>代码段3</b> 访问外部的本地变量</p>
</center>

<center>
    <img src="/Upvalue-Being-Closed.png">
    <p><b>图4</b> 上值被“关闭”之前及之后</p>
</center>

大部分编程语言为了避免这个问题，往往选择限制词法作用域（例如Python）或是不提供作为一等公民的函数（比如Pascal），或是同时限制这两方面（比如C语言）。函数式编程语言没有这些限制。对像 Scheme 和 ML 等非纯函数式编程语言的研究，为关于闭包的编译积累了大量的技术知识。然而这些研究工作却没有尝试过限制编译器得复杂度。例如在Bigloo（一个 Scheme 编译器的优化版本） 中，仅仅是对控制流的解析部分，就比整个Lua实现的十倍还要大： Bigloo 2.6f 的 Cfa 模块的源代码有106350行，而 Lua 5.0 的核心代码只有10155行。如第二节所述，Lua中的某些东西需要更简单的实现。

Lua使用一种叫做 *upvalue* 的结构体实现了闭包。所有外部本地变量都是间接通过上值 upvalue 来访问的。上值一开始指向变量在栈中所处的槽位（如图4中左侧所示）。当指向的变量越过了其作用域时，它会被转移到上值自身内部的一个槽位中（如图4中右侧所示）。因为是间接地通过上值中的指针来访问的，所以转移后对于任何读写变量的代码都是透明可用的。与内部函数不同，声明变量的函数会像访问自己的局部变量一样访问变量：直接在栈上访问。

为了在多个闭包之间正确地共享变化状态，对于每个变量最多只会创建一个上值并且按需共享它。为了确保其唯一性，Lua 持有了一个包含了所有开放上值（即仍然指向着栈的上值，如图4中标注为 *pending vars* 的列表）的链表。当Lua新建了一个闭包时，会遍历其所有的外部本地变量。对于每一个变量，如果可以在链表中找到对应的开放上值，那么会复用该上值。否则，Lua会创建一个新上值并插入到链表中。要注意，在该链表中查找时，通常只需要检查几个节点即可，因为嵌套函数的每个局部变量在该链表中最多只存在一个条目（所以对性能的影响并不大）。关闭上值是指不再被任何闭包所引用的变量，其最终会被GC清理掉。

有时函数所访问的外部本地变量可能并非属于其上层函数，而是属于外部的某个函数。在这种情况下，甚至在闭包被创建的时候，那个变量已经不在栈里了。Lua使用了一种叫做 *flat closures* 的机制来解决该问题。*flat closures* 的机制为：只要函数访问的外部变量并非上层函数中的本地变量，那么该变量也会进入到上层函数的闭包中。因此，当一个函数被实例化时，其所有的变量要么在其闭包中，要么在上层函数的栈中，要么在上层函数的闭包中。

## 6、线程和协程
从5.0版本开始，Lua实现了 *非对称协程 asymmetric coroutines（也称为 semisymmetric coroutines 或 semi-coroutines）* 。Lua标准库中支持三个关于协程的函数： **create**、**resume**、以及 **yield**（这三个函数都在命名空间 **coroutine** 中）。**create** 函数需要接收一个“主函数”，并用这个函数创建一个新的协程。它的返回一个表示协程的 *thread* 类型值。（和Lua中的其他值一样，协程也是一等公民。**resume** 函数会（重新）启动所给定的协程，调用该协程的主函数。**yield** 函数会挂起正在运行的协程并将控制流返回给（重新）启动这个协程的调用处。

理论上，每个协程都有自己的栈。（严格来说，每个协程有两个栈，将会在第7节中讨论它，但是我们可以先将其作为一个栈来考虑。）协程在Lua中是 *stackful* 的——我们可以从任意层嵌套调用中挂起一个协程。解释器只是简单的将整个栈放在一旁备用，并继续在另一个栈上开始运行。程序可以在任意处重启任何被挂起的协程。GC会清理那些无法访问的协程的栈。

*stackful* 的特性与一等公民的身份，使得Lua实现的协程等效于一个单向的连续过程（对于每个协程的代码来说，就像处理一个单向的过程逻辑一样）。因此，编码人员可以实现很多高级控制机制，诸如多线程协同、生成器、对称协程、回溯……等等。

Lua的协程实现中的一个关键点是解释器不可以使用其内部的C栈来实现解释器代码中的调用。（Python社区将遵循该限制的解释器称为 *stackless* 解释器。）当解释器主循环执行一个调用操作时，会在栈上新建一个槽位、调整一些指针，然后继续循环执行被调用函数的指令。相应的，做返回操作会移除栈顶上的槽位、调整一些指针，然后继续循环执行被调用函数的指令。不巧，这正是真实的CPU执行函数调用的过程。

不过，当解释器执行 *resume* 操作时，会递归调用解释器主函数。该调用负责执行所要恢复（启动）的协程，并使用该协程的栈来执行调用和返回。当新的协程循环调用了 *yield*，则会返回之前的解释器调用，将所有待处理的调用留在该协程栈中。换言之，Lua使用C栈来追溯在任意给定时间活跃的协程栈。每次协程让出都会返回之前的解释器循环，也就是调用相应的 *resume*。

在一些语言中，实现协程的一个根源上的难点就是如何处理对外部本地变量的引用。因为在某个协程中运行的函数可能是在另一个协程中创建出来的的，其可能会跨栈引用变量。从而形成了一些文章中所说的“仙人掌结构”。然而使用在第五节中所讨论的 *flat closures* 机制，就可以完全避免这个问题。

## 7、虚拟机
Lua运行程序的机制为，先将程序编译为虚拟机指令（操作码——opcodes）然后再执行它们。Lua编译每个函数时都会创建一个 *prototype*，其包含了一个该函数对应的字节码数组，以及一个Lua值（**TObjects**）数组，存储了该函数所用到的所有常量（常量字符串和数字常量）。

这些年来（从Lua首次发布的1993年开始）的Lua版本中，都是用的基于栈的虚拟机。直到2003年Lua 5.0 发布，开始使用基于寄存器的虚拟机。基于寄存器的虚拟机仍然会使用栈，用于分配激活的条目，寄存器存放在栈上。当Lua执行到一个函数中的时候，会从栈中分配一个足够容纳该函数寄存器的条目。其中所有的局部变量都分配在寄存器中。因此，访问局部变量会非常高效。

基于寄存器的代码会避免各种 “push” 和 “pop” 这种基于栈会做的操作，该操作会在栈上将值移来移去。这样的操作在Lua中成本非常昂贵，因为执行对第三节中所说的带标记的联合体的拷贝操作。所以，寄存器结构可以避免昂贵的值拷贝并减少了每个函数的指令总数。Java字节码也使用了基于寄存器的方法优化。还有一些文章认为基于寄存器的虚拟机很适合即时编译。

关于寄存器虚拟机有两个问题：编码大小和解码开销。一条寄存器VM中的指令往往需要明确指定其操作数，因此往往比栈VM中的等效指令要大。（例如，在Lua虚拟机中的单条指令大小为4个字节，但在很多常见的栈机制中的指令，包括Lua之前的版本中，往往是1到2个字节。）另一方面，寄存器VM产生的操作码数量比栈VM的要少，所以整体来看也没有很大。

大多数栈VM中的指令包含了隐式的操作数。而在寄存器VM中对于同等的调用必须从指令中解码出操作数。这样的解码会给解释器带来负担。但是有几方面的因素使得这种负担得以释怀。首先，栈VM也需要花费时间来处理隐式的操作数（例如栈顶的递增和递减）。其次，因为在寄存器VM中所有的操作数都在指令中并且指令是一个机器字，所以操作数的解码只涉及了些廉价操作，例如逻辑运算。此外，栈VM中的指令往往需要多个字节的操作数。例如在Java虚拟机（JVM）中，跳转和分支指令使用了2字节的偏移。因为字节对齐的原因，解释器不能一次抓取多个操作数（至少在可移植代码中不行，其必须总是假设代码要在最严格的字节对齐限制下的环境中运行）。在寄存器VM中，因为操作数包含在指令中，所以解释器不需要再单独抓取它们。

Lua虚拟机中有35种指令。大多数指令都是与语言结构直接对应的：算术、表的创建和索引、函数和方法调用、设置变量和获取值。也有传统的跳转指令以实现控制结构。图5展示了完整的指令集，并使用了一些符号来简要概括各指令用途：**R(X)** 意为第 **X** 个寄存器，**K(X)** 意为第 **X** 个常量，**RK(X)** 表示要么是 **R(X)** 要么是 **K(X-*k*)**，其根据 **X** 的值而定——当 **X** 小于 ***k*** （一个在内部构建的参数，通常为250）时就是 **R(X)** 。**G\[X\]** 意指全局表中的 **X** 字段。**U\[X\]** 指的是第 **X** 个上值。

<center>
    <img src="/Instruction-Of-LVM.png">
    <p><b>图5</b> Lua虚拟机中的指令</p>
</center>

寄存器是处在运行时栈中的，其本质上是一个数组。所以访问寄存器是很快的。常量和上值也是存在数组中的，所以它们的访问速度也很快。全局表是一个普通的Lua表。访问它需要做哈希，但是其性能很好，因为其只有（与变量名相对应的）字符串索引，而且正如第二节中所述，这些字符串的哈希值是都是提前计算好的。

如图6所示，Lua虚拟机中的指令是32位的，分为三到四个字段。**OP** 字段唯一标识了指令并且占据6个比特位。其他的字段用于标识操作数。字段A是常驻的，占有8个比特。字段B和字段C各占9比特。它们俩组合在一起用于表示18位的字段：**Bx**（无符号）和 **sBx**（有符号）。

<center>
    <img src="/Instruction-Layout.png">
    <p><b>图6</b> 指令结构</p>
</center>

大多数的指令都使用“三地址形式”，其中 **A** 指向将要持有结果的寄存器，**B** 和 **C** 指向操作数——它们可以是寄存器或常量（使用上文提到的 **RK(X)** 表示）。Lua中的很多常见操作可以编码为这种格式的单条指令。如递增一个局部变量： a = a + 1 ，会被编码为 **ADD** ***x*** ***y***，其中 ***x*** 表示持有局部变量的寄存器，***y*** 表示常量 1 。例如赋值语句 a = b.f ，当 a 和 b 都是局部变量时，也可以编码为单条指令 **GETTABLE** ***x*** ***y*** ***z***，其中 ***x*** 表示 a 对应的寄存器，***y*** 表示 b 的寄存器，而 ***z*** 表示索引常量字符串 "f"。（在Lua中，b.f 在语法上等同于 b\["f"\]，即在 b 中索引字符串 "f" 。）

分支指令需要比较两个指定的操作数然后再跳转一个偏移量，这带来了一些难点。将所有的数据都打包到单条指令的话会使得跳转偏移限制在256以内（当字段长度为带符号的9比特）。Lua所采用的方案是：从概念来说，测试指令在测试失败时会跳过下一条指令，而这里的下一条指令时一个普通的跳转指令，使用18位大小的偏移量。实际上，因测试指令总是会紧跟一个跳转指令的缘故，解释器会将它们一起放在一起执行。也就是说，当一个测试指令成功时，解释器会立即拿到下一条指令并执行跳转，而不是在下一个指令循环中执行。图7展示了一段Lua代码和对应的字节码。注意其中的条件和跳转指令。

<center>
    <img src="/Bytecode-For-Function.png">
    <p><b>图7</b> Lua函数及其对应的字节码</p>
</center>

图8展示了Lua编译器优化的简单示例，图9展示的是同样的代码在Lua4.0中所编译的字节码，其使用的是一个基于栈的、包含49种指令的虚拟机。注意使用基于寄存器的虚拟机所生成的字节码会短的多。对于每行可执行的语句，在Lua5.0中编译得到的是单条指令，而在Lua4.0中就需要三到四条指令。

<center>
    <img src="/Register-Based-Opcode.png">
    <p><b>图8</b> 基于寄存器的字节码</p>
</center>

<center>
    <img src="/Stack-Based-Opcode.png">
    <p><b>图9</b> 基于栈的字节码</p>
</center>

对于函数调用，Lua使用了一种叫做 ***“寄存器窗口（register window）”*** 的机制。它会从第一个未使用的寄存器开始，在连续的寄存器中计算调用参数（有些传入的参数是表达式，需要展开获取其值）。当执行调用时，这些寄存器会成为调用函数的活动条目的一部分，因此调用函数可以像访问局部变量一样来访问参数。当函数返回时，这些寄存器会被放回到调用方的活动条目中。

Lua的函数调用并行使用了两个栈。（正如第6节中所说，实际上每个协程都有各自的一对栈。）其中一个栈中放着的每个活跃函数的对应条目。这个条目存储着被调用的函数，函数调用时的返回地址，以及指向函数活动条目的起始索引。另一个栈是一个简单的巨大数组，其中存储了持有活动条目的Lua值。每个活动条目持有着函数的临时值（参数、局部变量等）。事实上，我们可以将第二个栈看做时第一个栈中的条目所对应的可变部分。

## 8、总结
在本文中，我们介绍了 Lua 5.0 实现中最具创新的部分：基于寄存器的虚拟机、数组和表的新优化算法，以及闭包的实现。

据我们所知，Lua 是第一个被广泛采用的基于寄存器的虚拟机的语言。对表的优化使得表在使用时（即在 1 ... n 范围内有足够多的键时），可以通过数组的形式实现。Lua对闭包的实现也是很独特的，我们将基于数组的堆栈与词法作用域的一阶函数结合起来使用，从而无需复杂的控制流分析。

图10中的表格展示了Lua新旧版本之间的一些简单性能的对比。测试是在一台运行 Linux 2.6 的 512 Mbytes Intel Pentium IV 机器上进行的，其中 Lua 使用 gcc 3.3 编译。Lua 4.0 既没有使用基于寄存器的虚拟机（其虚拟机基于堆栈），也没有使用表数组优化。Lua 5' 是没有表数组优化、尾调用和动态堆栈（与 CORUTINE 有关）的 Lua 5.0；Lua 5' 基本上是一个使用了基于寄存器的虚拟机的 Lua 4.0。

我们采用了 ***The Great Computer Language Shootout***（原地址是“http://www.bagley.org/~doug/shootout/” ，但是已经无法访问了） 中的所有测试用例，除了第一个测试用例（sum），它是一个简单的循环——将 1 到 n 的所有整数相加。其他测试在其他任务（函数调用、表/数组的访问等）上花费的时间较多，因此虚拟机的差异对总时间的影响较小。在使用数组（筛、堆排序和矩阵）的测试中，新的虚拟机与数组优化算法的结合可将运行时间最多缩短 40%。

要浏览Lua5.0的完整代码可以前往Lua官网：[https://www.lua.org/source/5.0/](https://www.lua.org/source/5.0/)。

<center>
    <img src="/Benchmarks.png">
    <p><b>图10</b> 性能基准（时间单位为秒，后跟相对于Lua4.0的百分比）</p>
</center>
